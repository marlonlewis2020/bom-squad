# Author: Marlon Lewis
# ID: 620001669

from queue import PriorityQueue

class Graph:
    # Class for Building Graph's Adjacency Matrix
    
    NODES = ("A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S")
    QTY = 0
    DEPTH = {}
    INF = float("Inf")
    AREA = ((0, (None, "A")), (1, ("A", "B")), (1, ("A", "C")),
            (1, ("A", "D")), (3, ("A", "E")), (3, ("A", "F")),
            (1, ("F", "G")), (1, ("F", "H")), (1, ("F", "I")),
            (5, ("F", "J")), (5, ("F", "K")), (1, ("D", "L")),
            (1, ("L", "M")), (2, ("D", "M")), (2, ("L", "N")),
            (2, ("M", "O")), (2, ("N", "P")), (2, ("N", "Q")),
            (2, ("Q", "R")), (3, ("R", "S")))
    
    # (weight, ())

    discovered = {}
    adjacency_matrix = {}
    area_capacity_matrix = {}
    # truck_capacity_matrix = {}

    def __init__(self, start_node):
        self.start_node = start_node
        self.visited = []
        self.pq = PriorityQueue()
        for node in self.NODES:
            # initialize discovered, adjacency matrix, distance matrix and other properties
            a_row = [None]*len(self.NODES)
            self.discovered[node] = [self.INF, None, node]
            self.adjacency_matrix[node] = a_row
        
        for node in self.NODES:
            nbrs = self.neighbours(node)
            for nbr in nbrs:
                if nbr == None: continue
                i = self.NODES.index(nbr)
                # print(self.adjacency_matrix[nbr], i)
                self.adjacency_matrix[node][i] = nbr
        self.discovered[start_node] = [0, None, start_node]
        self.pq.put((0,[None, start_node]))
        
    def discover( self, ele ):
        """Marks node ele as discovered, updating distances and priority list of neighbours of ele.

        Args:
            ele (char): node element value
        """
        if ele not in self.visited:
            depth = self.DEPTH.get(ele, None)
            if depth ==  None: self.DEPTH[ele] = 1
            
            if depth < self.DEPTH['max_depth']:
                # check for neighbours and add them to PQ, if max_depth not yet reached
                ele_weight =self.discovered[ele][0]
                nbrs = self.neighbours( ele )
                # check weight wt from ele to each nbr
                for nbr in nbrs:
                    elem = self.get_nbr_element( ele, nbr )
                    wt = elem[0]
                    # check sums so far for each nbr
                    nbr_sum = ele_weight + wt
                    # if value from ele to a nbr is less then update discovered pq with that ele/nbr item 
                    if nbr_sum < self.discovered[nbr][0] and nbr not in self.visited:
                        self.pq.put((nbr_sum, [ele, nbr])) # adds ele structure to priority list, if priority weight is less than previous weight of ele 
                        self.discovered[nbr] = [nbr_sum, ele, nbr] # adds ele item to discovered, if priority weight is less that previous weight of ele
                self.area_capacity_matrix[ele] = ele_weight # sets value for shortest distance from start node to current element        
            
    def get_adjacency_matrix(self):
        """
            Returns:
                Adjacency Matrix of all nodes as list of tuples
        """
        matrix = self.adjacency_matrix.items()
        return matrix

            
    def neighbours(self, character):
        """Provides a list of all the neighbours of a given node.

        Args:
            character (char): The value of the node that you want to find the neighbours of

        Returns:
            list: All the neighbours of the argument
        """
        nbrs = []
        # initialize empty list of neighbours
        for cap in self.AREA:
            if character.upper() in cap[1]: 
                dst = (0, 1) [cap[1].index(character.upper()) == 0]
                # gets the neighbour index
                dst_char = cap[1][dst]
                # gets the neighbour node
                if dst_char != None:
                    nbrs.append(dst_char)
                    # adds the neighbour to the neighbours list
        return nbrs
    
    def find_best_fit( self, depth, qty, location ):
        """Routine to discover and visit nodes in search for next best fit truck

        Args:
            depth (_type_): _description_
            qty (_type_): _description_
            location (_type_): _description_
        """
        self.DEPTH['max_depth'] = depth
        self.DEPTH[location] = 1
        
        while self.QTY <= qty:
            node = self.pq.get()
            # pop from pq
            ele = node[1][1]
            self.discover( ele )
            # discover immediate neighbours and mark as 
            self.visited.append(ele)
            # Mark ele as visited
            if self.QTY == qty : break
            
        self.pq = PriorityQueue()
    
    def get_area_capacity_matrix( self ):
        return self.area_capacity_matrix
            
    def get_nbr_element(self, ele, nbr ):
        """Provides a list with the wieght, start node and end node, if a neighbour relationship exists between the nodes

        Args:
            ele (char): start_node
            nbr (char): end_node

        Returns:
            list: [weight, start_node, end_node]
        """
        for area in self.AREA:
            edge = area[1]
            if ele in edge and nbr in edge:
                src = (0, 1) [edge.index(ele) == 0]
                dst = 1-src
                return [area[0], area[1][src], area[1][dst]]
        return [self.INF, ele, nbr]
    
if __name__=="__main__":
    g = Graph("F")
    print("ADJACENCY MATRIX:\n")
    for row in g.get_adjacency_matrix():
        print(list(row))
        
    for i in range(2): print()
    print("DISTANCE MATRIX:\n")
    for row in g.area_capacity_matrix().items():
        print(list(row))
    
    for i in range(2): print()
    print("NODES VISITED:\n")
    print(g.visited)
